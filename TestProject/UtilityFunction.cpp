//===================================================================================================================================
//【UtiltyFunction.h】
// [作成者]HAL東京GP12A332 11 菅野 樹
// [作成日]2019/08/07
// [更新日]2019/09/09
//===================================================================================================================================
#include "UtilityFunction.h"
using namespace utility;
//===================================================================================================================================
//【コンストラクタ】
//===================================================================================================================================
UtilityFunction::UtilityFunction()
{
}

//===================================================================================================================================
//【デストラクタ】
//===================================================================================================================================
UtilityFunction::~UtilityFunction()
{
}

//===================================================================================================================================
//【極座標から直交座標の３次元座標を求める】
//[引数]
//float radius	：動径			[定義域] 0<= radius <= ∞
//float theta	：極角(天頂角)  [定義域] 0<= theta  <= π
//float phi		：方位角(偏角)  [定義域] 0<= phi    <  2π
//[戻値]直交座標の3次元座標
//===================================================================================================================================
D3DXVECTOR3 UtilityFunction::fromTransformationPolar3D(float _radius,float _theta,float _phi)
{
	float radius = max(0, _radius);
	float theta = _theta;//wrap(_theta,0.0f,(float)(2.0f*D3DX_PI));
	float phi = (theta>D3DX_PI? -1 : 1) *  wrap(_phi,0.0f,(float)(2.0f*D3DX_PI));
	D3DXVECTOR3 result;
	result.x = 
		radius * sinf(theta) * cosf(phi);
	result.y = 
		radius * cosf(theta);
	result.z = 
		radius * sinf(theta) * sinf(phi);
	return result;
}
//===================================================================================================================================
//【直交座標から極座標の３値を求める】
//[引数]
//float radius	：動径			[定義域] 0<= radius <= ∞
//float theta	：極角(天頂角)  [定義域] 0<= theta  <= π
//float phi		：方位角(偏角)  [定義域] 0<= phi    <  2π
//[戻値]直交座標の3次元座標
//===================================================================================================================================
Polar3D UtilityFunction::fromRectangular3D(D3DXVECTOR3 coordinate)
{
	float x = coordinate.x;
	float y = coordinate.y;
	float z = coordinate.z;
	Polar3D result;
	result.radius = sqrtf(x*x+y*y+z*z);
	result.theta = (result.radius != 0) ? acosf(y/result.radius) : 0;
	result.phi = (x != 0) ? atanf(z/x) : 0;



	if (x > 0 && z > 0) {}						//++
	else if(x<0&&z>0)result.phi += D3DX_PI;		//-+
	else if(x<0&&z<=0)result.phi += D3DX_PI;	//--
	else if(x>0&&z<=0)result.phi += 2*D3DX_PI;	//+-

	return result;
}

//===================================================================================================================================
//【1次補間関数】
//===================================================================================================================================
float UtilityFunction::lerp(float start,float end, float rate)
{
	float result;
	clamp(rate, 0.0f, 1.0f);
	result = start * (1 - rate) + end * rate;
	return result;
}

//===================================================================================================================================
//【(int型)ラップ関数】
//===================================================================================================================================
int UtilityFunction::wrap(int x, int low, int high)
{
	assert(low < high);
	const int n = (x - low) % (high - low);
	return (n >= 0) ? (n + low) : (n + high);
}

//===================================================================================================================================
//【(float型)ラップ関数】
//===================================================================================================================================
float UtilityFunction::wrap(float x, float low, float high)
{
	assert(low < high);
	const float n = std::fmod(x - low,high - low);
	return (n >= 0) ? (n + low) : (n + high);
}

//===================================================================================================================================
//【クランプ関数】
//===================================================================================================================================
template<typename T>
T UtilityFunction::clamp(T x, T low, T high) {
	assert(low <= high);
	T result = max(x, low);
	result = min(result, high);

	return result;
}